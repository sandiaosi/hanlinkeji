<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd



       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 1. 开启spring注解 -->
    <!-- 说明：
                         参考资料：https://blog.csdn.net/chenlong220192/article/details/46723561
         1.<context:annotation-config/>的作用是向Spring容器注册以下四个BeanPostProcessor：
           A. AutowiredAnnotationBeanPostProcessor
           B. CommonAnnotationBeanPostProcessor
           C. PersistenceAnnotationBeanPostProcessor
           D. RequiredAnnotationBeanPostProcessor

         2.为什么要注册这四个BeanPostProcessor呢是为了让系统能够识别相应的注解。
           a、如果想使用@Autowired注解，那么就必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor Bean。
                                      传统声明方式如下：<bean class="org.springframework.beans.factory.annotation. AutowiredAnnotationBeanPostProcessor "/>
           b、如果想使用@ Resource 、@ PostConstruct、@ PreDestroy等注解    就必须声明CommonAnnotationBeanPostProcessor  Bean。
           c、如果想使用@PersistenceContext注解，                                                                      就必须声明PersistenceAnnotationBeanPostProcessor的Bean。
           d、如果想使用@Required的注解，                                                                                                就必须声明RequiredAnnotationBeanPostProcessor的Bean。

         3. 总结：以上这些注解是很常用的，如果按照传统的方式进行配置将会非常繁琐，
                                             所以Spring给我们提供了一个简便的方式：<context:annotation-config/>，使用该元素可以自动声明以上注解。

         4. 补充和注意：
            A. 由于<context:component-scan base-package=”xx.xx”/>也包含了自动注入上述Bean的功能，所以<context:annotation-config/> 可以省略。如果两者都进行了配置，则只有前者有效。
            B. <context:annotation-config> 是用于激活那些已经在spring容器里注册过的bean（无论是通过xml的方式还是通过package sanning的方式）上面的注解。
            C. <context:component-scan>除了具有<context:annotation-config>的功能之外，<context:component-scan>还可以在指定的package下扫描以及注册javabean 。
    -->
    <context:annotation-config/>


    <!-- 2. spring 可以自动去扫描 base-package下面的包或子包下面的Java文件，如果扫描到有Spring的相关注解的类，则把这些类注册为Spring的bean -->
    <!-- 说明：扫描com.hanlinkeji.edu包下的所有class文件，配置注解的类全都装入容器中进行管理 -->
    <context:component-scan base-package="com.hanlinkeji.edu"/>

    <!-- 3. spirng 逻辑bean自动注册  如果项目不需要刻意去除 -->
    <!-- 说明：添加注解驱动
         <mvc:annotation-driven>会自动注册RequestMappingHandlerMapping与RequestMappingHandlerAdapter两个Bean,
                          这是Spring MVC为@Controller分发请求所必需的，并且提供了数据绑定支持，
         @NumberFormatannotation支持， @DateTimeFormat支持,@Valid支持读写XML的支持（JAXB）和读写JSON的支持（默认Jackson）等功能。
    -->
    <mvc:annotation-driven>
        <mvc:message-converters register-defaults="true">

            <bean class="org.springframework.http.converter.StringHttpMessageConverter">
                <property name="supportedMediaTypes" value="text/plain;charset=UTF-8"/>
            </bean>

            <bean class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter">
                <property name="supportedMediaTypes">
                    <list>
                        <value>text/html;charset=UTF-8</value>
                        <value>application/json</value>
                    </list>
                </property>
                <property name="features">
                    <list>
                        <!-- 默认的意思就是不配置这个属性，配置了就不是默认了 -->
                        <!-- 是否输出值为null的字段 ，默认是false-->
                        <value>WriteMapNullValue</value>
                        <value>WriteNullNumberAsZero</value>
                        <value>WriteNullListAsEmpty</value>
                        <value>WriteNullStringAsEmpty</value>
                        <value>WriteNullBooleanAsFalse</value>
                        <value>WriteDateUseDateFormat</value>
                    </list>
                </property>
            </bean>
        </mvc:message-converters>
    </mvc:annotation-driven>


    <!-- 4. 配置静态资源  可选 -->
    <!-- 说明：静态资源处理
         1. location元素表示webapp目录下的xxx包下的所有文件
         2. mapping元素表示以/***开头的所有请求路径，如/static/a 或者/static/a/b；
         3. 该配置的作用是：DispatcherServlet不会拦截以/xxx 开头的所有请求路径，并当作静态资源交由Servlet处理
    -->
    <mvc:resources mapping="/webstatic/**" location="/webstatic/"/>


    <!-- 5. 加载资源文件 -->
    <!-- 说明：
                           资料参考：https://blog.csdn.net/zh417/article/details/1728874
                           资料参考：http://outofmemory.cn/code-snippet/3708/spring-properties-file-location
         PropertyPlaceholderConfigurer类就是bean factory post-processor的一种，它的作用是一个资源属性的配置器，能够将BeanFactory的里定义的内容放在一个以.propertis后缀的文件中

                          注意：如果加载的配置文件不存在会报出异常，此时会影响服务访问，最直接的现象就是各种注解失效导致控制层无法访问
     -->
    <bean id="webPropertyConfig"
          class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>classpath:main-setting.properties</value>
            </list>
        </property>
        <property name="placeholderPrefix" value="@{"/>
        <property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE"/>
    </bean>

    <!--===================== view resovler ===================== -->

    <!-- 5.0 配置视图解析器 -->
    <!-- 说明：
                         参考资料：https://www.cnblogs.com/porcoGT/p/4537064.html
         1. 网上很多实用的是org.springframework.web.servlet.view.InternalResourceViewResolver， 这个解析器它只能解析jsp
         2. 如果需要使用其他的解析器，可以配置其他spring接口实现的解析器。例如freeMarker的解析器FreeMarkerViewResolver

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
      <property name="prefix" value="/WEB-INF/views/" />
      <property name="suffix" value=".jsp" />
    </bean>
    -->

    <!--=====================  freemarker 融合   ===================== -->
    <bean id="freemarkerResolver"
          class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
        <property name="cache" value="true"/>
        <property name="suffix" value=".ftl"/>
        <property name="requestContextAttribute" value="request"/>
        <property name="exposeSpringMacroHelpers" value="true"/>
        <property name="exposeRequestAttributes" value="true"/>
        <property name="exposeSessionAttributes" value="true"/>
        <property name="allowSessionOverride" value="true"/>
        <property name="contentType" value="text/html;charset=utf-8"/><!--编码 -->
        <property name="viewClass"
                  value="org.springframework.web.servlet.view.freemarker.FreeMarkerView"/>
    </bean>


    <!-- -->
    <bean id="freemarkerConfig"
          class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
        <description>Required for Freemarker to work in web tier</description>
        <property name="configuration" ref="freemarkerConfiguration"/>
    </bean>


    <bean id="freemarkerConfiguration"
          class="org.springframework.ui.freemarker.FreeMarkerConfigurationFactoryBean">
        <!-- 模板加载路径 -->
        <property name="templateLoaderPaths">
            <list>
                <value>/WEB-INF/freemarker/</value>
            </list>
        </property>
        <property name="configLocation" value="classpath:freemarker.properties"/>
        <property name="defaultEncoding" value="utf-8"/>
        <property name="freemarkerVariables">
            <map>
                <entry key="xml_escape" value-ref="fmXmlEscape"/>
                <!--下面四个是在下面定义的-->
                <entry key="extends" value-ref="extendsDirective"/>
                <entry key="override" value-ref="overrideDirective"/>
                <entry key="block" value-ref="blockDirective"/>
                <entry key="super" value-ref="superDirective"/>
            </map>
        </property>
    </bean>
    <bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>
    <!-- freemaker  Directive-->
    <bean id="blockDirective" class="cn.org.rapid_framework.freemarker.directive.BlockDirective"/>
    <bean id="extendsDirective" class="cn.org.rapid_framework.freemarker.directive.ExtendsDirective"/>
    <bean id="overrideDirective" class="cn.org.rapid_framework.freemarker.directive.OverrideDirective"/>
    <bean id="superDirective" class="cn.org.rapid_framework.freemarker.directive.SuperDirective"/>

</beans>